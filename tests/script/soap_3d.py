# -*- coding: utf-8 -*-
"""SOAP_3D.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17EOlWoDiq_5gg5_X_QR0IMMOLkX7Nmtk
"""

import numpy as np
import plotly.graph_objects as go
import utils as utils
import numpy as np

import scipy.integrate as integrate
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import sympy as sympy
def gaussian_fun_alt_3D(sigma_3D, relative_distances_3D):
    # NB: r must be an array
    relative_xs = relative_distances_3D[:, 0]
    relative_ys = relative_distances_3D[:, 1]
    relative_zs = relative_distances_3D[:, 2]

    return lambda x, y, z: np.exp(1/(-2 * sigma_3D[0]**2) * (x - relative_xs[:, np.newaxis,np.newaxis, np.newaxis]) ** 2
                               + 1/(-2 * sigma_3D[1]**2) * (y - relative_ys[:, np.newaxis,np.newaxis, np.newaxis]) ** 2
                               + 1/(-2 * sigma_3D[2]**2) * (z - relative_zs[:, np.newaxis,np.newaxis, np.newaxis]) ** 2)
def trans_invariant_density_alt_3D(atom_positions, sigma_3D, r_cutoff = np.inf, origin_index = 0):
    relative_distances_3D  = atom_positions - atom_positions[origin_index]  # shape = (N, 2), N means #atoms, 2 means relative distance of (x and y)
    density = gaussian_fun_alt_3D(sigma_3D, relative_distances_3D)
    #def function(x, y, z):
    #    return np.sum(density(x, y, z), axis=0)
    #return function

    return lambda x, y, z: np.sum(density(x, y, z), axis=0)


# R_x = np.linspace(-100, 100, 100)
# R_y = np.linspace(-100, 100, 100)
# R_z = np.linspace(-100, 100, 100)
R_x = np.linspace(-5, 5, 100)
R_y = np.linspace(-5, 5, 100)
R_z = np.linspace(-5, 5, 100)
xv, yv, zv = np.meshgrid(R_x, R_y, R_z)

T_3D = np.array([0.1, 0.1, 0.1])
# T_3D = np.array([10, 20, 30])

############################  x      y,    z
atom_3D_position = np.array([[0,     0,    0],
                             [2,     2,    2],
                             [-1,   -1,   -1]])

############################  x      y,    z
# atom_3D_position = np.array([[10,     10,    10],
#                              [30,   30,  30,],
#                              [-50, -50, -50]])
# density_function_3D = trans_invariant_density_alt_3D(atom_3D_position + T_3D, np.array([10, 10, 10]))
# density_function_3D = trans_invariant_density_alt_3D(atom_3D_position + T_3D, np.array([2, 3, 4]))


density = trans_invariant_density_alt_3D(atom_3D_position + T_3D, np.array([2, 3, 4]))
result, error = utils.integrate_XYZ_numerically(density, -5, 5, -5, 5, -5, 5)
print("Numerical integral:", result, error)
print(f"Normalization constant = {utils.compute_normalisation_constant_to_N(result, 3)}")

#
#
#
#
# values = density_function_3D(xv, yv, zv)
#
#
# X, Y, Z = xv, yv, zv
#
# fig = go.Figure(data=go.Isosurface(
#     x=X.flatten(),
#     y=Y.flatten(),
#     z=Z.flatten(),
#     value=values.flatten(),
#     isomin=np.min(values),
#     isomax=np.max(values),
#     surface_count=20,
#     colorscale='Viridis',
#     showscale=True,
#     caps=dict(x_show=False, y_show=False, z_show=False),
# ))
#
#
# fig.update_layout(
#     title='3D Isosurface Plot',
#     scene=dict(
#         xaxis_title='X',
#         yaxis_title='Y',
#         zaxis_title='Z'
#     ),
#     width=800,
#     height=800,
# )
#
# fig.show()
# print(70 * "*")
